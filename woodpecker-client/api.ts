/**
 * Woodpecker CI API
 * Woodpecker is a simple yet powerful CI/CD engine with great extensibility. To get a personal access token (PAT) for authentication, please log in your Woodpecker server, and go to you personal profile page, by clicking the user icon at the top right.
 *
 * OpenAPI spec version: 2.4.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://woodpecker-ci-19fcc5.flakery.xyz/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Agent {
    'backend'?: string;
    'capacity'?: number;
    'created'?: number;
    'id'?: number;
    'lastContact'?: number;
    'name'?: string;
    'noSchedule'?: boolean;
    'ownerId'?: number;
    'platform'?: string;
    'token'?: string;
    'updated'?: number;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "backend",
            "baseName": "backend",
            "type": "string"
        },
        {
            "name": "capacity",
            "baseName": "capacity",
            "type": "number"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastContact",
            "baseName": "last_contact",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "noSchedule",
            "baseName": "no_schedule",
            "type": "boolean"
        },
        {
            "name": "ownerId",
            "baseName": "owner_id",
            "type": "number"
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Agent.attributeTypeMap;
    }
}

export class Config {
    'data'?: Array<number>;
    'hash'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Config.attributeTypeMap;
    }
}

export class Cron {
    'branch'?: string;
    'createdAt'?: number;
    'creatorId'?: number;
    'id'?: number;
    'name'?: string;
    'nextExec'?: number;
    'repoId'?: number;
    /**
    * @weekly, 3min, ...
    */
    'schedule'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "number"
        },
        {
            "name": "creatorId",
            "baseName": "creator_id",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nextExec",
            "baseName": "next_exec",
            "type": "number"
        },
        {
            "name": "repoId",
            "baseName": "repo_id",
            "type": "number"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Cron.attributeTypeMap;
    }
}

export class ErrorsPipelineError {
    'data'?: any;
    'isWarning'?: boolean;
    'message'?: string;
    'type'?: ErrorsPipelineErrorType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "isWarning",
            "baseName": "is_warning",
            "type": "boolean"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ErrorsPipelineErrorType"
        }    ];

    static getAttributeTypeMap() {
        return ErrorsPipelineError.attributeTypeMap;
    }
}

export class ErrorsPipelineErrorType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ErrorsPipelineErrorType.attributeTypeMap;
    }
}

export class Feed {
    'author'?: string;
    'authorAvatar'?: string;
    'authorEmail'?: string;
    'branch'?: string;
    'commit'?: string;
    'createdAt'?: number;
    'event'?: string;
    'finishedAt'?: number;
    'id'?: number;
    'message'?: string;
    'number'?: number;
    'ref'?: string;
    'refspec'?: string;
    'repoId'?: number;
    'startedAt'?: number;
    'status'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "authorAvatar",
            "baseName": "author_avatar",
            "type": "string"
        },
        {
            "name": "authorEmail",
            "baseName": "author_email",
            "type": "string"
        },
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "number"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "finishedAt",
            "baseName": "finished_at",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "refspec",
            "baseName": "refspec",
            "type": "string"
        },
        {
            "name": "repoId",
            "baseName": "repo_id",
            "type": "number"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Feed.attributeTypeMap;
    }
}

export class InlineResponse200 {
    'logLevel'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "logLevel",
            "baseName": "log-level",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    'source'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class LogEntry {
    'data'?: Array<number>;
    'id'?: number;
    'line'?: number;
    'stepId'?: number;
    'time'?: number;
    'type'?: LogEntryType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "line",
            "baseName": "line",
            "type": "number"
        },
        {
            "name": "stepId",
            "baseName": "step_id",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "LogEntryType"
        }    ];

    static getAttributeTypeMap() {
        return LogEntry.attributeTypeMap;
    }
}

export class LogEntryType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return LogEntryType.attributeTypeMap;
    }
}

export class ModelWorkflow {
    'agentId'?: number;
    'children'?: Array<Step>;
    'endTime'?: number;
    'environ'?: { [key: string]: string; };
    'error'?: string;
    'id'?: number;
    'name'?: string;
    'pid'?: number;
    'pipelineId'?: number;
    'platform'?: string;
    'startTime'?: number;
    'state'?: StatusValue;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agentId",
            "baseName": "agent_id",
            "type": "number"
        },
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<Step>"
        },
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "number"
        },
        {
            "name": "environ",
            "baseName": "environ",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pid",
            "baseName": "pid",
            "type": "number"
        },
        {
            "name": "pipelineId",
            "baseName": "pipeline_id",
            "type": "number"
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StatusValue"
        }    ];

    static getAttributeTypeMap() {
        return ModelWorkflow.attributeTypeMap;
    }
}

export class Org {
    'id'?: number;
    'isUser'?: boolean;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isUser",
            "baseName": "is_user",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Org.attributeTypeMap;
    }
}

export class OrgPerm {
    'admin'?: boolean;
    'member'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrgPerm.attributeTypeMap;
    }
}

export class Perm {
    'admin'?: boolean;
    'created'?: number;
    'pull'?: boolean;
    'push'?: boolean;
    'synced'?: number;
    'updated'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "number"
        },
        {
            "name": "pull",
            "baseName": "pull",
            "type": "boolean"
        },
        {
            "name": "push",
            "baseName": "push",
            "type": "boolean"
        },
        {
            "name": "synced",
            "baseName": "synced",
            "type": "number"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Perm.attributeTypeMap;
    }
}

export class Pipeline {
    'author'?: string;
    'authorAvatar'?: string;
    'authorEmail'?: string;
    'branch'?: string;
    'changedFiles'?: Array<string>;
    'commit'?: string;
    'createdAt'?: number;
    'deployTo'?: string;
    'errors'?: Array<ErrorsPipelineError>;
    'event'?: WebhookEvent;
    'finishedAt'?: number;
    'forgeUrl'?: string;
    'id'?: number;
    'isPrerelease'?: boolean;
    'message'?: string;
    'number'?: number;
    'parent'?: number;
    'prLabels'?: Array<string>;
    'ref'?: string;
    'refspec'?: string;
    'reviewedAt'?: number;
    'reviewedBy'?: string;
    /**
    * uses reported user for webhooks and name of cron for cron pipelines
    */
    'sender'?: string;
    'startedAt'?: number;
    'status'?: StatusValue;
    'timestamp'?: number;
    'title'?: string;
    'updatedAt'?: number;
    'variables'?: { [key: string]: string; };
    'workflows'?: Array<ModelWorkflow>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "authorAvatar",
            "baseName": "author_avatar",
            "type": "string"
        },
        {
            "name": "authorEmail",
            "baseName": "author_email",
            "type": "string"
        },
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "changedFiles",
            "baseName": "changed_files",
            "type": "Array<string>"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "number"
        },
        {
            "name": "deployTo",
            "baseName": "deploy_to",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<ErrorsPipelineError>"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "WebhookEvent"
        },
        {
            "name": "finishedAt",
            "baseName": "finished_at",
            "type": "number"
        },
        {
            "name": "forgeUrl",
            "baseName": "forge_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isPrerelease",
            "baseName": "is_prerelease",
            "type": "boolean"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "number"
        },
        {
            "name": "prLabels",
            "baseName": "pr_labels",
            "type": "Array<string>"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "refspec",
            "baseName": "refspec",
            "type": "string"
        },
        {
            "name": "reviewedAt",
            "baseName": "reviewed_at",
            "type": "number"
        },
        {
            "name": "reviewedBy",
            "baseName": "reviewed_by",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "string"
        },
        {
            "name": "startedAt",
            "baseName": "started_at",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "StatusValue"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "number"
        },
        {
            "name": "variables",
            "baseName": "variables",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "workflows",
            "baseName": "workflows",
            "type": "Array<ModelWorkflow>"
        }    ];

    static getAttributeTypeMap() {
        return Pipeline.attributeTypeMap;
    }
}

export class PipelineOptions {
    'branch'?: string;
    'variables'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "variables",
            "baseName": "variables",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return PipelineOptions.attributeTypeMap;
    }
}

export class PullRequest {
    'index'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "index",
            "baseName": "index",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PullRequest.attributeTypeMap;
    }
}

export class Registry {
    'address'?: string;
    'id'?: number;
    'password'?: string;
    'username'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Registry.attributeTypeMap;
    }
}

export class Repo {
    'active'?: boolean;
    'allowPr'?: boolean;
    'avatarUrl'?: string;
    'cancelPreviousPipelineEvents'?: Array<WebhookEvent>;
    'cloneUrl'?: string;
    'cloneUrlSsh'?: string;
    'configFile'?: string;
    'defaultBranch'?: string;
    /**
    * ForgeRemoteID is the unique identifier for the repository on the forge.
    */
    'forgeRemoteId'?: string;
    'forgeUrl'?: string;
    'fullName'?: string;
    'gated'?: boolean;
    'id'?: number;
    'name'?: string;
    'netrcOnlyTrusted'?: boolean;
    'orgId'?: number;
    'owner'?: string;
    'prEnabled'?: boolean;
    '_private'?: boolean;
    'scm'?: SCMKind;
    'timeout'?: number;
    'trusted'?: boolean;
    'visibility'?: RepoVisibility;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "allowPr",
            "baseName": "allow_pr",
            "type": "boolean"
        },
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "cancelPreviousPipelineEvents",
            "baseName": "cancel_previous_pipeline_events",
            "type": "Array<WebhookEvent>"
        },
        {
            "name": "cloneUrl",
            "baseName": "clone_url",
            "type": "string"
        },
        {
            "name": "cloneUrlSsh",
            "baseName": "clone_url_ssh",
            "type": "string"
        },
        {
            "name": "configFile",
            "baseName": "config_file",
            "type": "string"
        },
        {
            "name": "defaultBranch",
            "baseName": "default_branch",
            "type": "string"
        },
        {
            "name": "forgeRemoteId",
            "baseName": "forge_remote_id",
            "type": "string"
        },
        {
            "name": "forgeUrl",
            "baseName": "forge_url",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "gated",
            "baseName": "gated",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "netrcOnlyTrusted",
            "baseName": "netrc_only_trusted",
            "type": "boolean"
        },
        {
            "name": "orgId",
            "baseName": "org_id",
            "type": "number"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "prEnabled",
            "baseName": "pr_enabled",
            "type": "boolean"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "scm",
            "baseName": "scm",
            "type": "SCMKind"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        },
        {
            "name": "trusted",
            "baseName": "trusted",
            "type": "boolean"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "RepoVisibility"
        }    ];

    static getAttributeTypeMap() {
        return Repo.attributeTypeMap;
    }
}

export class RepoPatch {
    'allowPr'?: boolean;
    'cancelPreviousPipelineEvents'?: Array<WebhookEvent>;
    'configFile'?: string;
    'gated'?: boolean;
    'netrcOnlyTrusted'?: boolean;
    'timeout'?: number;
    'trusted'?: boolean;
    'visibility'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowPr",
            "baseName": "allow_pr",
            "type": "boolean"
        },
        {
            "name": "cancelPreviousPipelineEvents",
            "baseName": "cancel_previous_pipeline_events",
            "type": "Array<WebhookEvent>"
        },
        {
            "name": "configFile",
            "baseName": "config_file",
            "type": "string"
        },
        {
            "name": "gated",
            "baseName": "gated",
            "type": "boolean"
        },
        {
            "name": "netrcOnlyTrusted",
            "baseName": "netrc_only_trusted",
            "type": "boolean"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        },
        {
            "name": "trusted",
            "baseName": "trusted",
            "type": "boolean"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepoPatch.attributeTypeMap;
    }
}

export class RepoVisibility {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return RepoVisibility.attributeTypeMap;
    }
}

export class SCMKind {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return SCMKind.attributeTypeMap;
    }
}

export class Secret {
    'events'?: Array<WebhookEvent>;
    'id'?: number;
    'images'?: Array<string>;
    'name'?: string;
    'orgId'?: number;
    'repoId'?: number;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<WebhookEvent>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "images",
            "baseName": "images",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "orgId",
            "baseName": "org_id",
            "type": "number"
        },
        {
            "name": "repoId",
            "baseName": "repo_id",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Secret.attributeTypeMap;
    }
}

export class StatusValue {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return StatusValue.attributeTypeMap;
    }
}

export class Step {
    'endTime'?: number;
    'error'?: string;
    'exitCode'?: number;
    'id'?: number;
    'name'?: string;
    'pid'?: number;
    'pipelineId'?: number;
    'ppid'?: number;
    'startTime'?: number;
    'state'?: StatusValue;
    'type'?: StepType;
    'uuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endTime",
            "baseName": "end_time",
            "type": "number"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "exitCode",
            "baseName": "exit_code",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pid",
            "baseName": "pid",
            "type": "number"
        },
        {
            "name": "pipelineId",
            "baseName": "pipeline_id",
            "type": "number"
        },
        {
            "name": "ppid",
            "baseName": "ppid",
            "type": "number"
        },
        {
            "name": "startTime",
            "baseName": "start_time",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StatusValue"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "StepType"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Step.attributeTypeMap;
    }
}

export class StepType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return StepType.attributeTypeMap;
    }
}

export class Task {
    'agentId'?: number;
    'data'?: Array<number>;
    'depStatus'?: { [key: string]: StatusValue; };
    'dependencies'?: Array<string>;
    'id'?: string;
    'labels'?: { [key: string]: string; };
    'runOn'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agentId",
            "baseName": "agent_id",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        },
        {
            "name": "depStatus",
            "baseName": "dep_status",
            "type": "{ [key: string]: StatusValue; }"
        },
        {
            "name": "dependencies",
            "baseName": "dependencies",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "runOn",
            "baseName": "run_on",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Task.attributeTypeMap;
    }
}

export class User {
    /**
    * Admin indicates the user is a system administrator.  NOTE: If the username is part of the WOODPECKER_ADMIN environment variable, this value will be set to true on login.
    */
    'admin'?: boolean;
    /**
    * the avatar url for this user.
    */
    'avatarUrl'?: string;
    /**
    * Email is the email address for this user.  required: true
    */
    'email'?: string;
    /**
    * the id for this user.  required: true
    */
    'id'?: number;
    /**
    * Login is the username for this user.  required: true
    */
    'login'?: string;
    /**
    * OrgID is the of the user as model.Org.
    */
    'orgId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "orgId",
            "baseName": "org_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class WebhookEvent {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return WebhookEvent.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Agent": Agent,
    "Config": Config,
    "Cron": Cron,
    "ErrorsPipelineError": ErrorsPipelineError,
    "ErrorsPipelineErrorType": ErrorsPipelineErrorType,
    "Feed": Feed,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "LogEntry": LogEntry,
    "LogEntryType": LogEntryType,
    "ModelWorkflow": ModelWorkflow,
    "Org": Org,
    "OrgPerm": OrgPerm,
    "Perm": Perm,
    "Pipeline": Pipeline,
    "PipelineOptions": PipelineOptions,
    "PullRequest": PullRequest,
    "Registry": Registry,
    "Repo": Repo,
    "RepoPatch": RepoPatch,
    "RepoVisibility": RepoVisibility,
    "SCMKind": SCMKind,
    "Secret": Secret,
    "StatusValue": StatusValue,
    "Step": Step,
    "StepType": StepType,
    "Task": Task,
    "User": User,
    "WebhookEvent": WebhookEvent,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AgentsApiApiKeys {
}

export class AgentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AgentsApiApiKeys, value: string) {
        (this.authentications as any)[AgentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an agent
     * @param authorization Insert your personal access token
     * @param agent the agent&#39;s id
     * @param {*} [options] Override http request options.
     */
    public agentsAgentDelete (authorization: string, agent: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/agents/{agent}'
            .replace('{' + 'agent' + '}', encodeURIComponent(String(agent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsAgentDelete.');
        }

        // verify required parameter 'agent' is not null or undefined
        if (agent === null || agent === undefined) {
            throw new Error('Required parameter agent was null or undefined when calling agentsAgentDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get agent information
     * @param authorization Insert your personal access token
     * @param agent the agent&#39;s id
     * @param {*} [options] Override http request options.
     */
    public agentsAgentGet (authorization: string, agent: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Agent;  }> {
        const localVarPath = this.basePath + '/agents/{agent}'
            .replace('{' + 'agent' + '}', encodeURIComponent(String(agent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsAgentGet.');
        }

        // verify required parameter 'agent' is not null or undefined
        if (agent === null || agent === undefined) {
            throw new Error('Required parameter agent was null or undefined when calling agentsAgentGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Agent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Agent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update agent information
     * @param authorization Insert your personal access token
     * @param agent the agent&#39;s id
     * @param agentData the agent&#39;s data
     * @param {*} [options] Override http request options.
     */
    public agentsAgentPatch (authorization: string, agent: number, agentData: Agent, options: any = {}) : Promise<{ response: http.ClientResponse; body: Agent;  }> {
        const localVarPath = this.basePath + '/agents/{agent}'
            .replace('{' + 'agent' + '}', encodeURIComponent(String(agent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsAgentPatch.');
        }

        // verify required parameter 'agent' is not null or undefined
        if (agent === null || agent === undefined) {
            throw new Error('Required parameter agent was null or undefined when calling agentsAgentPatch.');
        }

        // verify required parameter 'agentData' is not null or undefined
        if (agentData === null || agentData === undefined) {
            throw new Error('Required parameter agentData was null or undefined when calling agentsAgentPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(agentData, "Agent")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Agent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Agent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get agent tasks
     * @param authorization Insert your personal access token
     * @param agent the agent&#39;s id
     * @param {*} [options] Override http request options.
     */
    public agentsAgentTasksGet (authorization: string, agent: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Task>;  }> {
        const localVarPath = this.basePath + '/agents/{agent}/tasks'
            .replace('{' + 'agent' + '}', encodeURIComponent(String(agent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsAgentTasksGet.');
        }

        // verify required parameter 'agent' is not null or undefined
        if (agent === null || agent === undefined) {
            throw new Error('Required parameter agent was null or undefined when calling agentsAgentTasksGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Task>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Task>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get agent list
     * @param authorization Insert your personal access token
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public agentsGet (authorization: string, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Agent>;  }> {
        const localVarPath = this.basePath + '/agents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Agent>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Agent>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new agent with a random token so a new agent can connect to the server
     * @param authorization Insert your personal access token
     * @param agent the agent&#39;s data (only &#39;name&#39; and &#39;no_schedule&#39; are read)
     * @param {*} [options] Override http request options.
     */
    public agentsPost (authorization: string, agent: Agent, options: any = {}) : Promise<{ response: http.ClientResponse; body: Agent;  }> {
        const localVarPath = this.basePath + '/agents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling agentsPost.');
        }

        // verify required parameter 'agent' is not null or undefined
        if (agent === null || agent === undefined) {
            throw new Error('Required parameter agent was null or undefined when calling agentsPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(agent, "Agent")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Agent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Agent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BadgesApiApiKeys {
}

export class BadgesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BadgesApiApiKeys, value: string) {
        (this.authentications as any)[BadgesApiApiKeys[key]].apiKey = value;
    }
    /**
     * CCMenu displays the pipeline status of projects on a CI server as an item in the Mac's menu bar. More details on how to install, you can find at http://ccmenu.org/ The response format adheres to CCTray v1 Specification, https://cctray.org/v1/
     * @summary Provide pipeline status information to the CCMenu tool
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public badgesRepoIdCcXmlGet (repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/badges/{repo_id}/cc.xml'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling badgesRepoIdCcXmlGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get status badge, SVG format
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public badgesRepoIdStatusSvgGet (repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/badges/{repo_id}/status.svg'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling badgesRepoIdStatusSvgGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }
    /**
     * event source streaming for compatibility with quic and http2
     * @summary Event stream
     * @param {*} [options] Override http request options.
     */
    public streamEventsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/stream/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationApiApiKeys {
}

export class OrganizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get organization by id
     * @param authorization Insert your personal access token
     * @param orgId the organziation&#39;s id
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdGet (authorization: string, orgId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Org>;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdGet.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Org>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Org>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationPermissionsApiApiKeys {
}

export class OrganizationPermissionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationPermissionsApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationPermissionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the permissions of the current user in the given organization
     * @param authorization Insert your personal access token
     * @param orgId the organziation&#39;s id
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdPermissionsGet (authorization: string, orgId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OrgPerm>;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/permissions'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdPermissionsGet.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdPermissionsGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OrgPerm>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OrgPerm>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationSecretsApiApiKeys {
}

export class OrganizationSecretsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationSecretsApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationSecretsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the organization secret list
     * @param authorization Insert your personal access token
     * @param orgId the org&#39;s id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdSecretsGet (authorization: string, orgId: string, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Secret>;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/secrets'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdSecretsGet.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdSecretsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Secret>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Secret>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Persist/create an organization secret
     * @param authorization Insert your personal access token
     * @param orgId the org&#39;s id
     * @param secretData the new secret
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdSecretsPost (authorization: string, orgId: string, secretData: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/secrets'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdSecretsPost.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdSecretsPost.');
        }

        // verify required parameter 'secretData' is not null or undefined
        if (secretData === null || secretData === undefined) {
            throw new Error('Required parameter secretData was null or undefined when calling orgsOrgIdSecretsPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secretData, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the named secret from an organization
     * @param authorization Insert your personal access token
     * @param orgId the org&#39;s id
     * @param secret the secret&#39;s name
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdSecretsSecretDelete (authorization: string, orgId: string, secret: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/secrets/{secret}'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdSecretsSecretDelete.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdSecretsSecretDelete.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling orgsOrgIdSecretsSecretDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the named organization secret
     * @param authorization Insert your personal access token
     * @param orgId the org&#39;s id
     * @param secret the secret&#39;s name
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdSecretsSecretGet (authorization: string, orgId: string, secret: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/secrets/{secret}'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdSecretsSecretGet.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdSecretsSecretGet.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling orgsOrgIdSecretsSecretGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an organization secret
     * @param authorization Insert your personal access token
     * @param orgId the org&#39;s id
     * @param secret the secret&#39;s name
     * @param secretData the update secret data
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIdSecretsSecretPatch (authorization: string, orgId: string, secret: string, secretData: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/orgs/{org_id}/secrets/{secret}'
            .replace('{' + 'org_id' + '}', encodeURIComponent(String(orgId)))
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsOrgIdSecretsSecretPatch.');
        }

        // verify required parameter 'orgId' is not null or undefined
        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling orgsOrgIdSecretsSecretPatch.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling orgsOrgIdSecretsSecretPatch.');
        }

        // verify required parameter 'secretData' is not null or undefined
        if (secretData === null || secretData === undefined) {
            throw new Error('Required parameter secretData was null or undefined when calling orgsOrgIdSecretsSecretPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secretData, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationsApiApiKeys {
}

export class OrganizationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationsApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Lookup organization by full-name
     * @param authorization Insert your personal access token
     * @param orgFullName the organizations full-name / slug
     * @param {*} [options] Override http request options.
     */
    public orgLookupOrgFullNameGet (authorization: string, orgFullName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Org;  }> {
        const localVarPath = this.basePath + '/org/lookup/{org_full_name}'
            .replace('{' + 'org_full_name' + '}', encodeURIComponent(String(orgFullName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgLookupOrgFullNameGet.');
        }

        // verify required parameter 'orgFullName' is not null or undefined
        if (orgFullName === null || orgFullName === undefined) {
            throw new Error('Required parameter orgFullName was null or undefined when calling orgLookupOrgFullNameGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Org;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Org");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrgsApiApiKeys {
}

export class OrgsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrgsApiApiKeys, value: string) {
        (this.authentications as any)[OrgsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns all registered orgs in the system. Requires admin rights.
     * @summary Get all orgs
     * @param authorization Insert your personal access token
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public orgsGet (authorization: string, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Org>;  }> {
        const localVarPath = this.basePath + '/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Org>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Org>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the given org. Requires admin rights.
     * @summary Delete an org
     * @param authorization Insert your personal access token
     * @param id the org&#39;s id
     * @param {*} [options] Override http request options.
     */
    public orgsIdDelete (authorization: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling orgsIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgsIdDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PipelineLogsApiApiKeys {
}

export class PipelineLogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PipelineLogsApiApiKeys, value: string) {
        (this.authentications as any)[PipelineLogsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes log
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdLogsNumberDelete (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/logs/{number}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdLogsNumberDelete.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdLogsNumberDelete.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdLogsNumberDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log information
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param stepID the step id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdLogsNumberStepIDGet (authorization: string, repoId: number, number: number, stepID: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<LogEntry>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/logs/{number}/{stepID}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)))
            .replace('{' + 'stepID' + '}', encodeURIComponent(String(stepID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdLogsNumberStepIDGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdLogsNumberStepIDGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdLogsNumberStepIDGet.');
        }

        // verify required parameter 'stepID' is not null or undefined
        if (stepID === null || stepID === undefined) {
            throw new Error('Required parameter stepID was null or undefined when calling reposRepoIdLogsNumberStepIDGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LogEntry>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LogEntry>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log stream
     * @param repoId the repository id
     * @param pipeline the number of the pipeline
     * @param stepID the step id
     * @param {*} [options] Override http request options.
     */
    public streamLogsRepoIdPipelineStepIDGet (repoId: number, pipeline: number, stepID: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/stream/logs/{repo_id}/{pipeline}/{stepID}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'pipeline' + '}', encodeURIComponent(String(pipeline)))
            .replace('{' + 'stepID' + '}', encodeURIComponent(String(stepID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling streamLogsRepoIdPipelineStepIDGet.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling streamLogsRepoIdPipelineStepIDGet.');
        }

        // verify required parameter 'stepID' is not null or undefined
        if (stepID === null || stepID === undefined) {
            throw new Error('Required parameter stepID was null or undefined when calling streamLogsRepoIdPipelineStepIDGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PipelineQueuesApiApiKeys {
}

export class PipelineQueuesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PipelineQueuesApiApiKeys, value: string) {
        (this.authentications as any)[PipelineQueuesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List pipeline queues
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public pipelinesGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Feed>;  }> {
        const localVarPath = this.basePath + '/pipelines';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling pipelinesGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Feed>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Feed>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * TODO: link the InfoT response object - this is blocked, until the `swaggo/swag` tool dependency is v1.18.12 or newer
     * @summary Get pipeline queue information
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public queueInfoGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: { [key: string]: string; };  }> {
        const localVarPath = this.basePath + '/queue/info';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling queueInfoGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: { [key: string]: string; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: string; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Block til pipeline queue has a running item
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public queueNorunningpipelinesGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/queue/norunningpipelines';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling queueNorunningpipelinesGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Pause a pipeline queue
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public queuePausePost (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/queue/pause';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling queuePausePost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Resume a pipeline queue
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public queueResumePost (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/queue/resume';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling queueResumePost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PipelinesApiApiKeys {
}

export class PipelinesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PipelinesApiApiKeys, value: string) {
        (this.authentications as any)[PipelinesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get pipelines, current running and past ones
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Pipeline>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Pipeline>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Pipeline>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start pipelines in gated repos
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberApprovePost (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}/approve'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberApprovePost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberApprovePost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberApprovePost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Cancels a pipeline
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberCancelPost (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}/cancel'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberCancelPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberCancelPost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberCancelPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Pipeline configuration
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberConfigGet (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Config>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}/config'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberConfigGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberConfigGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberConfigGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Config>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Config>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Decline pipelines in gated repos
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberDeclinePost (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}/decline'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberDeclinePost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberDeclinePost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberDeclinePost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Pipeline information by number
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline, OR &#39;latest&#39;
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberGet (authorization: string, repoId: number, number: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Restarts a pipeline optional with altered event, deploy or environment
     * @summary Restart a pipeline
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param number the number of the pipeline
     * @param event override the event type
     * @param deployTo override the target deploy value
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesNumberPost (authorization: string, repoId: number, number: number, event?: string, deployTo?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines/{number}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesNumberPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesNumberPost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposRepoIdPipelinesNumberPost.');
        }

        if (event !== undefined) {
            localVarQueryParameters['event'] = ObjectSerializer.serialize(event, "string");
        }

        if (deployTo !== undefined) {
            localVarQueryParameters['deploy_to'] = ObjectSerializer.serialize(deployTo, "string");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Run/trigger a pipelines
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param options the options for the pipeline to run
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPipelinesPost (authorization: string, repoId: number, options: PipelineOptions, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pipelines'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPipelinesPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPipelinesPost.');
        }

        // verify required parameter 'options' is not null or undefined
        if (options === null || options === undefined) {
            throw new Error('Required parameter options was null or undefined when calling reposRepoIdPipelinesPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(options, "PipelineOptions")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProcessProfilingAndDebuggingApiApiKeys {
}

export class ProcessProfilingAndDebuggingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProcessProfilingAndDebuggingApiApiKeys, value: string) {
        (this.authentications as any)[ProcessProfilingAndDebuggingApiApiKeys[key]].apiKey = value;
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary Get pprof stack traces that led to blocking on synchronization primitives
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofBlockGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/block';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofBlockGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary Get the command line invocation of the current program
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofCmdlineGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/cmdline';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofCmdlineGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary List available pprof profiles (HTML)
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary Get pprof stack traces of all current goroutines
     * @param authorization Insert your personal access token
     * @param debug Use debug&#x3D;2 as a query parameter to export in the same format as an un-recovered panic
     * @param {*} [options] Override http request options.
     */
    public debugPprofGoroutineGet (authorization: string, debug?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/goroutine';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofGoroutineGet.');
        }

        if (debug !== undefined) {
            localVarQueryParameters['debug'] = ObjectSerializer.serialize(debug, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary Get pprof heap dump, a sampling of memory allocations of live objects
     * @param authorization Insert your personal access token
     * @param gc You can specify gc&#x3D;heap to run GC before taking the heap sample
     * @param {*} [options] Override http request options.
     */
    public debugPprofHeapGet (authorization: string, gc?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/heap';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofHeapGet.');
        }

        if (gc !== undefined) {
            localVarQueryParameters['gc'] = ObjectSerializer.serialize(gc, "string");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug After you get the profile file, use the go tool pprof command to investigate the profile.
     * @summary Get pprof CPU profile
     * @param authorization Insert your personal access token
     * @param seconds You can specify the duration in the seconds GET parameter.
     * @param {*} [options] Override http request options.
     */
    public debugPprofProfileGet (authorization: string, seconds: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofProfileGet.');
        }

        // verify required parameter 'seconds' is not null or undefined
        if (seconds === null || seconds === undefined) {
            throw new Error('Required parameter seconds was null or undefined when calling debugPprofProfileGet.');
        }

        if (seconds !== undefined) {
            localVarQueryParameters['seconds'] = ObjectSerializer.serialize(seconds, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug Looks up the program counters listed in the request, responding with a table mapping program counters to function names. The requested program counters can be provided via GET + query parameters, or POST + body parameters. Program counters shall be space delimited.
     * @summary Get pprof program counters mapping to function names
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofSymbolGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/symbol';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofSymbolGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug Looks up the program counters listed in the request, responding with a table mapping program counters to function names. The requested program counters can be provided via GET + query parameters, or POST + body parameters. Program counters shall be space delimited.
     * @summary Get pprof program counters mapping to function names
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofSymbolPost (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/symbol';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofSymbolPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug
     * @summary Get pprof stack traces that led to the creation of new OS threads
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public debugPprofThreadcreateGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/threadcreate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofThreadcreateGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Only available, when server was started with WOODPECKER_LOG_LEVEL=debug After you get the profile file, use the go tool pprof command to investigate the profile.
     * @summary Get a trace of execution of the current program
     * @param authorization Insert your personal access token
     * @param seconds You can specify the duration in the seconds GET parameter.
     * @param {*} [options] Override http request options.
     */
    public debugPprofTraceGet (authorization: string, seconds: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/debug/pprof/trace';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling debugPprofTraceGet.');
        }

        // verify required parameter 'seconds' is not null or undefined
        if (seconds === null || seconds === undefined) {
            throw new Error('Required parameter seconds was null or undefined when calling debugPprofTraceGet.');
        }

        if (seconds !== undefined) {
            localVarQueryParameters['seconds'] = ObjectSerializer.serialize(seconds, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositoriesApiApiKeys {
}

export class RepositoriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositoriesApiApiKeys, value: string) {
        (this.authentications as any)[RepositoriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List all repositories on the server. Requires admin rights.
     * @param authorization Insert your personal access token
     * @param active only list active repos
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposGet (authorization: string, active?: boolean, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Repo>;  }> {
        const localVarPath = this.basePath + '/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposGet.');
        }

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Repo>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repo>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get repository by full-name
     * @param authorization Insert your personal access token
     * @param repoFullName the repository full-name / slug
     * @param {*} [options] Override http request options.
     */
    public reposLookupRepoFullNameGet (authorization: string, repoFullName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/lookup/{repo_full_name}'
            .replace('{' + 'repo_full_name' + '}', encodeURIComponent(String(repoFullName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposLookupRepoFullNameGet.');
        }

        // verify required parameter 'repoFullName' is not null or undefined
        if (repoFullName === null || repoFullName === undefined) {
            throw new Error('Required parameter repoFullName was null or undefined when calling reposLookupRepoFullNameGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Activate a repository
     * @param authorization Insert your personal access token
     * @param forgeRemoteId the id of a repository at the forge
     * @param {*} [options] Override http request options.
     */
    public reposPost (authorization: string, forgeRemoteId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposPost.');
        }

        // verify required parameter 'forgeRemoteId' is not null or undefined
        if (forgeRemoteId === null || forgeRemoteId === undefined) {
            throw new Error('Required parameter forgeRemoteId was null or undefined when calling reposPost.');
        }

        if (forgeRemoteId !== undefined) {
            localVarQueryParameters['forge_remote_id'] = ObjectSerializer.serialize(forgeRemoteId, "string");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Repair all repositories on the server. Requires admin rights.
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public reposRepairPost (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/repair';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepairPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get repository branches
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdBranchesGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/branches'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdBranchesGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdBranchesGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change a repository's owner, to the one holding the access token
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdChownPost (authorization: string, repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/chown'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdChownPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdChownPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a repository
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdDelete (authorization: string, repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdDelete.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get repository information
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdGet (authorization: string, repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Move a repository to a new owner
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param to the username to move the repository to
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdMovePost (authorization: string, repoId: number, to: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/move'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdMovePost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdMovePost.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling reposRepoIdMovePost.');
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change a repository
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param repo the repository&#39;s information
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPatch (authorization: string, repoId: number, repo: RepoPatch, options: any = {}) : Promise<{ response: http.ClientResponse; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPatch.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposRepoIdPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(repo, "RepoPatch")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The repository permission, according to the used access token.
     * @summary Repository permission information
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPermissionsGet (authorization: string, repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Perm;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/permissions'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPermissionsGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPermissionsGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Perm;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Perm");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List active pull requests
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdPullRequestsGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<PullRequest>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/pull_requests'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdPullRequestsGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdPullRequestsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<PullRequest>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PullRequest>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Repair a repository
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRepairPost (authorization: string, repoId: number, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/repair'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRepairPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRepairPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositoryCronJobsApiApiKeys {
}

export class RepositoryCronJobsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositoryCronJobsApiApiKeys, value: string) {
        (this.authentications as any)[RepositoryCronJobsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a cron job by id
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param cron the cron job id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronCronDelete (authorization: string, repoId: number, cron: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron/{cron}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'cron' + '}', encodeURIComponent(String(cron)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronCronDelete.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronCronDelete.');
        }

        // verify required parameter 'cron' is not null or undefined
        if (cron === null || cron === undefined) {
            throw new Error('Required parameter cron was null or undefined when calling reposRepoIdCronCronDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a cron job by id
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param cron the cron job id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronCronGet (authorization: string, repoId: number, cron: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Cron;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron/{cron}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'cron' + '}', encodeURIComponent(String(cron)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronCronGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronCronGet.');
        }

        // verify required parameter 'cron' is not null or undefined
        if (cron === null || cron === undefined) {
            throw new Error('Required parameter cron was null or undefined when calling reposRepoIdCronCronGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cron;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cron");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a cron job
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param cron the cron job id
     * @param cronJob the cron job data
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronCronPatch (authorization: string, repoId: number, cron: string, cronJob: Cron, options: any = {}) : Promise<{ response: http.ClientResponse; body: Cron;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron/{cron}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'cron' + '}', encodeURIComponent(String(cron)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronCronPatch.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronCronPatch.');
        }

        // verify required parameter 'cron' is not null or undefined
        if (cron === null || cron === undefined) {
            throw new Error('Required parameter cron was null or undefined when calling reposRepoIdCronCronPatch.');
        }

        // verify required parameter 'cronJob' is not null or undefined
        if (cronJob === null || cronJob === undefined) {
            throw new Error('Required parameter cronJob was null or undefined when calling reposRepoIdCronCronPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cronJob, "Cron")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cron;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cron");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start a cron job now
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param cron the cron job id
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronCronPost (authorization: string, repoId: number, cron: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron/{cron}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'cron' + '}', encodeURIComponent(String(cron)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronCronPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronCronPost.');
        }

        // verify required parameter 'cron' is not null or undefined
        if (cron === null || cron === undefined) {
            throw new Error('Required parameter cron was null or undefined when calling reposRepoIdCronCronPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the cron job list
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Cron>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Cron>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Cron>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Persist/creat a cron job
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param cronJob the new cron job
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdCronPost (authorization: string, repoId: number, cronJob: Cron, options: any = {}) : Promise<{ response: http.ClientResponse; body: Cron;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/cron'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdCronPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdCronPost.');
        }

        // verify required parameter 'cronJob' is not null or undefined
        if (cronJob === null || cronJob === undefined) {
            throw new Error('Required parameter cronJob was null or undefined when calling reposRepoIdCronPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(cronJob, "Cron")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Cron;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Cron");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositoryRegistriesApiApiKeys {
}

export class RepositoryRegistriesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositoryRegistriesApiApiKeys, value: string) {
        (this.authentications as any)[RepositoryRegistriesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the registry list
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRegistryGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Registry>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/registry'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRegistryGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRegistryGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Registry>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Registry>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Persist/create a registry
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param registry the new registry data
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRegistryPost (authorization: string, repoId: number, registry: Registry, options: any = {}) : Promise<{ response: http.ClientResponse; body: Registry;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/registry'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRegistryPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRegistryPost.');
        }

        // verify required parameter 'registry' is not null or undefined
        if (registry === null || registry === undefined) {
            throw new Error('Required parameter registry was null or undefined when calling reposRepoIdRegistryPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registry, "Registry")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Registry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Registry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a named registry
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param registry the registry name
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRegistryRegistryDelete (authorization: string, repoId: number, registry: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/registry/{registry}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'registry' + '}', encodeURIComponent(String(registry)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRegistryRegistryDelete.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRegistryRegistryDelete.');
        }

        // verify required parameter 'registry' is not null or undefined
        if (registry === null || registry === undefined) {
            throw new Error('Required parameter registry was null or undefined when calling reposRepoIdRegistryRegistryDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a named registry
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param registry the registry name
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRegistryRegistryGet (authorization: string, repoId: number, registry: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Registry;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/registry/{registry}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'registry' + '}', encodeURIComponent(String(registry)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRegistryRegistryGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRegistryRegistryGet.');
        }

        // verify required parameter 'registry' is not null or undefined
        if (registry === null || registry === undefined) {
            throw new Error('Required parameter registry was null or undefined when calling reposRepoIdRegistryRegistryGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Registry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Registry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a named registry
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param registry the registry name
     * @param registryData the attributes for the registry
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdRegistryRegistryPatch (authorization: string, repoId: number, registry: string, registryData: Registry, options: any = {}) : Promise<{ response: http.ClientResponse; body: Registry;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/registry/{registry}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'registry' + '}', encodeURIComponent(String(registry)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdRegistryRegistryPatch.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdRegistryRegistryPatch.');
        }

        // verify required parameter 'registry' is not null or undefined
        if (registry === null || registry === undefined) {
            throw new Error('Required parameter registry was null or undefined when calling reposRepoIdRegistryRegistryPatch.');
        }

        // verify required parameter 'registryData' is not null or undefined
        if (registryData === null || registryData === undefined) {
            throw new Error('Required parameter registryData was null or undefined when calling reposRepoIdRegistryRegistryPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(registryData, "Registry")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Registry;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Registry");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositorySecretsApiApiKeys {
}

export class RepositorySecretsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositorySecretsApiApiKeys, value: string) {
        (this.authentications as any)[RepositorySecretsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the secret list
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdSecretsGet (authorization: string, repoId: number, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Secret>;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/secrets'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdSecretsGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdSecretsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Secret>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Secret>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Persist/create a secret
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param secret the new secret
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdSecretsPost (authorization: string, repoId: number, secret: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/secrets'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdSecretsPost.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdSecretsPost.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling reposRepoIdSecretsPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secret, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a named secret
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param secretName the secret name
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdSecretsSecretNameDelete (authorization: string, repoId: number, secretName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/secrets/{secretName}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'secretName' + '}', encodeURIComponent(String(secretName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdSecretsSecretNameDelete.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdSecretsSecretNameDelete.');
        }

        // verify required parameter 'secretName' is not null or undefined
        if (secretName === null || secretName === undefined) {
            throw new Error('Required parameter secretName was null or undefined when calling reposRepoIdSecretsSecretNameDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a named secret
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param secretName the secret name
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdSecretsSecretNameGet (authorization: string, repoId: number, secretName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/secrets/{secretName}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'secretName' + '}', encodeURIComponent(String(secretName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdSecretsSecretNameGet.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdSecretsSecretNameGet.');
        }

        // verify required parameter 'secretName' is not null or undefined
        if (secretName === null || secretName === undefined) {
            throw new Error('Required parameter secretName was null or undefined when calling reposRepoIdSecretsSecretNameGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a named secret
     * @param authorization Insert your personal access token
     * @param repoId the repository id
     * @param secretName the secret name
     * @param secret the secret itself
     * @param {*} [options] Override http request options.
     */
    public reposRepoIdSecretsSecretNamePatch (authorization: string, repoId: number, secretName: string, secret: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/repos/{repo_id}/secrets/{secretName}'
            .replace('{' + 'repo_id' + '}', encodeURIComponent(String(repoId)))
            .replace('{' + 'secretName' + '}', encodeURIComponent(String(secretName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling reposRepoIdSecretsSecretNamePatch.');
        }

        // verify required parameter 'repoId' is not null or undefined
        if (repoId === null || repoId === undefined) {
            throw new Error('Required parameter repoId was null or undefined when calling reposRepoIdSecretsSecretNamePatch.');
        }

        // verify required parameter 'secretName' is not null or undefined
        if (secretName === null || secretName === undefined) {
            throw new Error('Required parameter secretName was null or undefined when calling reposRepoIdSecretsSecretNamePatch.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling reposRepoIdSecretsSecretNamePatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secret, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecretsApiApiKeys {
}

export class SecretsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SecretsApiApiKeys, value: string) {
        (this.authentications as any)[SecretsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the global secret list
     * @param authorization Insert your personal access token
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public secretsGet (authorization: string, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Secret>;  }> {
        const localVarPath = this.basePath + '/secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling secretsGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Secret>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Secret>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Persist/create a global secret
     * @param authorization Insert your personal access token
     * @param secret the secret object data
     * @param {*} [options] Override http request options.
     */
    public secretsPost (authorization: string, secret: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling secretsPost.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling secretsPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secret, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a global secret by name
     * @param authorization Insert your personal access token
     * @param secret the secret&#39;s name
     * @param {*} [options] Override http request options.
     */
    public secretsSecretDelete (authorization: string, secret: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/secrets/{secret}'
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling secretsSecretDelete.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling secretsSecretDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a global secret by name
     * @param authorization Insert your personal access token
     * @param secret the secret&#39;s name
     * @param {*} [options] Override http request options.
     */
    public secretsSecretGet (authorization: string, secret: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/secrets/{secret}'
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling secretsSecretGet.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling secretsSecretGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a global secret by name
     * @param authorization Insert your personal access token
     * @param secret the secret&#39;s name
     * @param secretData the secret&#39;s data
     * @param {*} [options] Override http request options.
     */
    public secretsSecretPatch (authorization: string, secret: string, secretData: Secret, options: any = {}) : Promise<{ response: http.ClientResponse; body: Secret;  }> {
        const localVarPath = this.basePath + '/secrets/{secret}'
            .replace('{' + 'secret' + '}', encodeURIComponent(String(secret)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling secretsSecretPatch.');
        }

        // verify required parameter 'secret' is not null or undefined
        if (secret === null || secret === undefined) {
            throw new Error('Required parameter secret was null or undefined when calling secretsSecretPatch.');
        }

        // verify required parameter 'secretData' is not null or undefined
        if (secretData === null || secretData === undefined) {
            throw new Error('Required parameter secretData was null or undefined when calling secretsSecretPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(secretData, "Secret")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Secret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Secret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SystemApiApiKeys {
}

export class SystemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SystemApiApiKeys, value: string) {
        (this.authentications as any)[SystemApiApiKeys[key]].apiKey = value;
    }
    /**
     * If everything is fine, just a 204 will be returned, a 500 signals server state is unhealthy.
     * @summary Health information
     * @param {*} [options] Override http request options.
     */
    public healthzGet (options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/healthz';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Incoming webhook from forge
     * @param hook the webhook payload; forge is automatically detected
     * @param {*} [options] Override http request options.
     */
    public hookPost (hook: any, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/hook';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'hook' is not null or undefined
        if (hook === null || hook === undefined) {
            throw new Error('Required parameter hook was null or undefined when calling hookPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(hook, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Endpoint returns the current logging level. Requires admin rights.
     * @summary Current log level
     * @param {*} [options] Override http request options.
     */
    public logLevelGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/log-level';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Endpoint sets the current logging level. Requires admin rights.
     * @summary Set log level
     * @param authorization Insert your personal access token
     * @param logLevel the new log level, one of &lt;debug,trace,info,warn,error,fatal,panic,disabled&gt;
     * @param {*} [options] Override http request options.
     */
    public logLevelPost (authorization: string, logLevel: object, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/log-level';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling logLevelPost.');
        }

        // verify required parameter 'logLevel' is not null or undefined
        if (logLevel === null || logLevel === undefined) {
            throw new Error('Required parameter logLevel was null or undefined when calling logLevelPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(logLevel, "object")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get server's signature public key
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public signaturePublicKeyGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/signature/public-key';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling signaturePublicKeyGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Endpoint returns the server version and build information.
     * @summary Get version
     * @param {*} [options] Override http request options.
     */
    public versionGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/version';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * Feed entries can be used to display information on the latest builds.
     * @summary A feed entry for a build.
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public userFeedGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/user/feed';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userFeedGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the currently authenticated user.
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public userGet (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the currently authenticated User's Repository list
     * @summary Get user's repos
     * @param authorization Insert your personal access token
     * @param all query all repos, including inactive ones
     * @param {*} [options] Override http request options.
     */
    public userReposGet (authorization: string, all?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Repo>;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userReposGet.');
        }

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "boolean");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Repo>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repo>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reset's the current personal access token of the user and returns a new one.
     * @summary Reset a token
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public userTokenDelete (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/user/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userTokenDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return the token of the current user as string
     * @param authorization Insert your personal access token
     * @param {*} [options] Override http request options.
     */
    public userTokenPost (authorization: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/user/token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling userTokenPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns all registered, active users in the system. Requires admin rights.
     * @summary Get all users
     * @param authorization Insert your personal access token
     * @param page for response pagination, page offset number
     * @param perPage for response pagination, max items per page
     * @param {*} [options] Override http request options.
     */
    public usersGet (authorization: string, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling usersGet.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['perPage'] = ObjectSerializer.serialize(perPage, "number");
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deletes the given user. Requires admin rights.
     * @summary Delete a user
     * @param authorization Insert your personal access token
     * @param login the user&#39;s login name
     * @param {*} [options] Override http request options.
     */
    public usersLoginDelete (authorization: string, login: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{login}'
            .replace('{' + 'login' + '}', encodeURIComponent(String(login)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling usersLoginDelete.');
        }

        // verify required parameter 'login' is not null or undefined
        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling usersLoginDelete.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a user with the specified login name. Requires admin rights.
     * @summary Get a user
     * @param authorization Insert your personal access token
     * @param login the user&#39;s login name
     * @param {*} [options] Override http request options.
     */
    public usersLoginGet (authorization: string, login: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{login}'
            .replace('{' + 'login' + '}', encodeURIComponent(String(login)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling usersLoginGet.');
        }

        // verify required parameter 'login' is not null or undefined
        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling usersLoginGet.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Changes the data of an existing user. Requires admin rights.
     * @summary Change a user
     * @param authorization Insert your personal access token
     * @param login the user&#39;s login name
     * @param user the user&#39;s data
     * @param {*} [options] Override http request options.
     */
    public usersLoginPatch (authorization: string, login: string, user: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{login}'
            .replace('{' + 'login' + '}', encodeURIComponent(String(login)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling usersLoginPatch.');
        }

        // verify required parameter 'login' is not null or undefined
        if (login === null || login === undefined) {
            throw new Error('Required parameter login was null or undefined when calling usersLoginPatch.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling usersLoginPatch.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Creates a new user account with the specified external login. Requires admin rights.
     * @summary Create a user
     * @param authorization Insert your personal access token
     * @param user the user&#39;s data
     * @param {*} [options] Override http request options.
     */
    public usersPost (authorization: string, user: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling usersPost.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling usersPost.');
        }

        localVarHeaderParams['Authorization'] = ObjectSerializer.serialize(authorization, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(user, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
